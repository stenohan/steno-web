<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>속기사 2인 1조 시스템</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            min-height: 100vh;
            padding: 20px;
            color: #e8e8e8;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: none;
            backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }



        .status-bar {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            color: #a8b2ff;
            padding: 20px 24px;
            border-radius: 8px;
            margin-bottom: 28px;
            text-align: center;
            font-size: 1rem;
            font-weight: 600;
            border: 1px solid rgba(102, 126, 234, 0.2);
            position: relative;
            overflow: hidden;
        }

        .status-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .stenographer-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 28px;
            margin-bottom: 20px;
        }

        .viewer-section {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 28px;
            position: relative;
            width: 100%;
        }

        .stenographer-panel {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 10px;
            padding: 14px;
            border: 2px solid rgba(255, 255, 255, 0.08);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: visible;
        }

        .stenographer-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transform: scaleX(0);
            transition: transform 0.4s ease;
        }

        .stenographer-panel.active {
            border-color: rgba(102, 126, 234, 0.6);
            background: rgba(102, 126, 234, 0.08);
            box-shadow: 0 25px 50px rgba(102, 126, 234, 0.25), 0 0 30px rgba(102, 126, 234, 0.3);
            transform: translateY(-2px);
            animation: glow 2s ease-in-out infinite alternate;
        }

        .stenographer-panel.active::before {
            transform: scaleX(1);
        }

        @keyframes glow {
            from {
                box-shadow: 0 25px 50px rgba(102, 126, 234, 0.25), 0 0 30px rgba(102, 126, 234, 0.3);
            }
            to {
                box-shadow: 0 25px 50px rgba(102, 126, 234, 0.35), 0 0 40px rgba(102, 126, 234, 0.4);
            }
        }

        .stenographer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
            padding-top: 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stenographer-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: #ffffff;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stenographer-title.steno1 {
            color: #667eea;
        }

        .stenographer-title.steno2 {
            color: #764ba2;
        }

        .status-indicator {
            padding: 8px 16px;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 600;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .status-active {
            background: linear-gradient(135deg, #00d4aa 0%, #0099cc 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(0, 212, 170, 0.3);
        }

        .status-standby {
            background: rgba(255, 255, 255, 0.1);
            color: #b0b0b0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .input-area {
            width: 100%;
            height: 200px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px;
            font-size: 1rem;
            line-height: 1.7;
            resize: none;
            transition: all 0.3s ease;
            font-family: inherit;
            background: rgba(255, 255, 255, 0.02);
            color: #e8e8e8;
            margin-bottom: 0;
        }

        .input-area:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
            background: rgba(255, 255, 255, 0.05);
        }

        .input-area::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        .matching-highlight {
            background: rgba(102, 126, 234, 0.15);
            border-radius: 4px;
            padding: 2px 4px;
            margin: 0 1px;
            transition: all 0.3s ease;
        }

        .matching-highlight.partial {
            background: rgba(102, 126, 234, 0.08);
        }

        .matching-highlight.complete {
            background: rgba(102, 126, 234, 0.2);
        }

        .viewer-section {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 28px;
            position: relative;
        }

        .memo-section {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 28px;
            position: relative;
        }

        .viewer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .memo-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .viewer-title {
            font-size: 1.3rem;
            font-weight: 700;
            color: #ffffff;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .memo-title {
            font-size: 1.3rem;
            font-weight: 700;
            color: #ffffff;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 16px;
        }

        .viewer-controls {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .display-controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .display-controls label {
            font-size: 0.9rem;
            color: #b0b0b0;
            font-weight: 500;
        }

        .display-controls select {
            padding: 8px 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            font-size: 0.9rem;
            background: rgba(255, 255, 255, 0.05);
            color: #e8e8e8;
            transition: all 0.3s ease;
        }

        .display-controls select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .font-controls {
            display: flex;
            gap: 8px;
        }

        .font-controls button {
            padding: 8px 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            color: #b0b0b0;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .stenographer-controls {
            display: flex;
            gap: 8px;
        }

        .stenographer-controls button {
            padding: 6px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            color: #b0b0b0;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .stenographer-controls button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
            color: #ffffff;
        }

        .font-controls button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
            color: #ffffff;
            transform: translateY(-1px);
        }

        .viewer-content {
            min-height: 200px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            font-size: 1.15rem;
            line-height: 1.8;
            color: #e8e8e8;
            white-space: pre-wrap;
            overflow-y: auto;
            max-height: 200px;
            word-break: keep-all;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            width: 100%;
        }

        .memo-content {
            min-height: 200px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            font-size: 1.15rem;
            line-height: 1.8;
            color: #e8e8e8;
            white-space: pre-wrap;
            overflow-y: auto;
            max-height: 200px;
            word-break: keep-all;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            width: 100%;
            resize: none;
            font-family: inherit;
            transition: all 0.3s ease;
        }

        .memo-content:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
            background: rgba(255, 255, 255, 0.05);
        }

        .memo-content::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        .viewer-content::-webkit-scrollbar {
            width: 8px;
        }

        .viewer-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .viewer-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        .viewer-content::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .memo-content::-webkit-scrollbar {
            width: 8px;
        }

        .memo-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .memo-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        .memo-content::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .controls {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 7px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e8e8e8;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }



        .word-match-indicator {
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.1) 0%, rgba(255, 152, 0, 0.1) 100%);
            border: 1px solid rgba(255, 193, 7, 0.3);
            padding: 16px;
            border-radius: 6px;
            margin-top: 16px;
            font-size: 0.9rem;
            color: #ffd54f;
            font-weight: 500;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .match-words-setting {
            display: flex;
            gap: 4px;
            align-items: center;
            background: transparent;
            padding: 20px;
            margin-bottom: 24px;
        }

        .match-words-setting label {
            font-weight: 600;
            color: #b0b0b0;
            font-size: 0.95rem;
        }

        .number-input-container {
            display: flex;
            align-items: center;
            background: transparent;
            border: none;
            width: fit-content;
            gap: 4px;
            margin-left: 4px;
        }

        .number-btn {
            padding: 4px 4px;
            border: none;
            background: transparent;
            color: #b0b0b0;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 600;
            transition: all 0.3s ease;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0;
        }

        .number-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #ffffff;
        }

        .number-btn:active {
            background: rgba(102, 126, 234, 0.3);
        }

        #matchWordsCount {
            padding: 4px 4px;
            border: none;
            background: transparent;
            color: #e8e8e8;
            font-size: 0.9rem;
            font-weight: 600;
            text-align: center;
            width: 30px;
            outline: none;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0;
        }

        @media (max-width: 768px) {
            .stenographer-section {
                grid-template-columns: 1fr;
            }
            
            .viewer-controls {
                flex-direction: column;
                align-items: flex-start;
                gap: 16px;
            }

            .controls {
                flex-direction: column;
                align-items: center;
            }

            .btn {
                width: 100%;
                max-width: 300px;
                justify-content: center;
            }
        }

        /* 추가적인 시각적 효과 */
        .container::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #667eea, #764ba2, #667eea);
            border-radius: 24px;
            z-index: -1;
            opacity: 0.3;
            filter: blur(20px);
        }

        /* 유틸리티 창 추가 */
        .utility-section {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 28px;
            position: relative;
            max-width: 100%;
        }
        .utility-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 12px;
        }
        .utility-tab {
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(102, 126, 234, 0.15);
            color: #b0b0b0;
            font-weight: 700;
            font-size: 1rem;
            border-radius: 8px 8px 0 0;
            padding: 6px 18px;
            cursor: pointer;
            transition: all 0.2s;
            outline: none;
        }
        .utility-tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            border-bottom: 1px solid transparent;
            z-index: 2;
        }
        .utility-content {
            min-height: 200px;
            padding: 18px 10px 10px 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 0 0 8px 8px;
            font-size: 1.15rem;
            line-height: 1.8;
            color: #e8e8e8;
            white-space: pre-wrap;
            overflow-y: auto;
            max-height: 200px;
            word-break: keep-all;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-top: none;
            position: relative;
            width: 100%;
        }
        .utility-placeholder {
            color: #b0b0b0;
            text-align: center;
            padding: 40px 0;
            font-size: 1.05rem;
        }

        /* CSS 수정 */
        .stenographer-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 28px;
            margin-bottom: 20px;
        }
        .stenographer-panel,
        .viewer-section,
        .utility-section {
            min-width: 0;
            min-height: 0;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        /* 각 창이 2x2 그리드에 정확히 들어가도록 grid-area 지정 */
        .stenographer-panel:nth-child(1) { grid-row: 1; grid-column: 1; }
        .stenographer-panel:nth-child(2) { grid-row: 1; grid-column: 2; }
        .viewer-section { grid-row: 2; grid-column: 1; }
        .utility-section { grid-row: 2; grid-column: 2; }

        /* 메모장 제목 삭제 (이미 삭제됨) */

        /* 유틸리티 탭 겹침/디자인 개선 */
        .utility-section { position: relative; }
        .utility-tabs {
            position: absolute;
            top: 0;
            left: 0;
            height: 24px;
            z-index: 10;
            display: flex;
            gap: 0;
        }
        .utility-tab {
            width: 24px;
            height: 24px;
            font-size: 0.9rem;
            border-radius: 7px 7px 0 0;
            padding: 0;
            margin-left: -8px; /* 1/3 겹침 */
            border: 1.5px solid rgba(102, 126, 234, 0.25);
            background: rgba(255,255,255,0.10);
            color: #b0b0b0;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 1;
            box-shadow: 0 2px 8px 0 rgba(102,126,234,0.04);
        }
        .utility-tab:first-child { margin-left: 0; }
        .utility-tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            border-bottom: 1.5px solid transparent;
            z-index: 3;
        }
        .utility-tab:not(.active) {
            opacity: 0.85;
            z-index: 1;
        }
        .utility-tab#utilityTab2:not(.active) {
            z-index: 0;
        }
        .utility-content {
            flex: 1 1 0;
            padding: 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 0 0 8px 8px;
            font-size: 1.15rem;
            line-height: 1.8;
            color: #e8e8e8;
            white-space: pre-wrap;
            overflow-y: auto;
            max-height: 100%;
            word-break: keep-all;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-top: none;
            position: relative;
            width: 100%;
        }
        .utility-content:empty {
            overflow-y: hidden;
        }

        /* 뷰어창 하단 버튼/컨트롤 개선 */
        .viewer-section {
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            height: 100%;
        }
        .viewer-content {
            flex: 1 1 0;
            margin-bottom: 0;
            min-height: 200px;
            max-height: none;
        }
        .viewer-header {
            display: flex;
            justify-content: flex-start;
            align-items: flex-end;
            margin-top: 0;
            padding-top: 0;
            border-top: none;
            gap: 10px;
            padding-bottom: 32px;
            padding-left: 0;
            width: 100%;
        }
        .viewer-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-left: 0;
        }
        .display-controls select {
            padding: 4px 8px;
            font-size: 0.7rem;
            height: 24px;
            min-width: 60px;
        }
        .font-controls button, .display-controls select, .font-controls button, .viewer-header button {
            padding: 4px 8px !important;
            font-size: 0.7rem !important;
            height: 24px !important;
            min-width: 24px;
        }
        .font-controls button {
            min-width: 24px;
        }
        .viewer-header .display-controls label { display: none; }
    </style>
</head>
<body>
    <div class="container">


        <div class="match-words-setting">
            <label>WM</label>
            <div class="number-input-container">
                <button class="number-btn" onclick="increaseMatchWords()">▲</button>
                <input type="number" id="matchWordsCount" min="3" max="7" value="3" readonly>
                <button class="number-btn" onclick="decreaseMatchWords()">▼</button>
            </div>
        </div>

        <div class="status-bar" id="statusBar">
            속기사 1번이 현재 송출권한 상태입니다
        </div>

        <div class="stenographer-section">
            <div class="stenographer-panel active" id="steno1Panel">
                <textarea 
                    class="input-area" 
                    id="input1"
                    placeholder="여기에 입력하세요..."
                    autocomplete="off"
                ></textarea>
                <div class="stenographer-header">
                    <div class="stenographer-controls">
                        <button onclick="changeStenoFontSize(1, -2)">A-</button>
                        <button onclick="changeStenoFontSize(1, 2)">A+</button>
                    </div>
                    <div class="status-indicator status-active" id="status1">🟢 송출권한</div>
                </div>
                <div class="word-match-indicator" id="match1" style="display: none;"></div>
            </div>

            <div class="stenographer-panel" id="steno2Panel">
                <textarea 
                    class="input-area" 
                    id="input2"
                    placeholder="여기에 입력하세요..."
                    autocomplete="off"
                ></textarea>
                <div class="stenographer-header">
                    <div class="stenographer-controls">
                        <button onclick="changeStenoFontSize(2, -2)">A-</button>
                        <button onclick="changeStenoFontSize(2, 2)">A+</button>
                    </div>
                    <div class="status-indicator status-standby" id="status2">⏸️ 대기</div>
                </div>
                <div class="word-match-indicator" id="match2" style="display: none;"></div>
            </div>

            <!-- 유틸리티 창 -->
            <div class="utility-section">
                <div class="utility-tabs">
                    <button class="utility-tab active" id="utilityTab1" onclick="selectUtilityTab(1)">1</button>
                    <button class="utility-tab" id="utilityTab2" onclick="selectUtilityTab(2)">2</button>
                </div>
                <div class="utility-content" id="utilityContent1"></div>
                <div class="utility-content" id="utilityContent2" style="display:none;"></div>
            </div>

            <!-- 뷰어창 -->
            <div class="viewer-section">
                <div class="viewer-content" id="viewerContent"></div>
                <div class="viewer-header">
                    <div class="viewer-controls">
                        <div class="display-controls">
                            <select id="displayMode">
                                <option value="1">1단어 완성 후 표시</option>
                                <option value="2">2단어 완성 후 표시</option>
                            </select>
                        </div>
                        <div class="font-controls">
                            <button onclick="changeFontSize(-2)">A-</button>
                            <button onclick="changeFontSize(2)">A+</button>
                            <button onclick="clearViewer()">🗑️</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-primary" onclick="manualSwitch()">🔄 수동 권한 전환</button>
            <button class="btn btn-secondary" onclick="resetDemo()">🔄 데모 리셋</button>
            <button class="btn btn-primary" onclick="openViewer()">📺 뷰어모드</button>
        </div>
    </div>

    <script>
        let activeStenographer = 1; // 송출권한을 가진 속기사 (1 또는 2)
        let currentFontSize = 1.1;
        let accumulatedText = ""; // 모니터링 화면에 누적된 텍스트
        let matchWordsCount = 3; // 자동 전환을 위한 어절 수
        let displayDelayWords = 1; // 모니터링 표시 지연 단어 수
        
        const input1 = document.getElementById('input1');
        const input2 = document.getElementById('input2');
        const viewerContent = document.getElementById('viewerContent');
        const statusBar = document.getElementById('statusBar');
        const steno1Panel = document.getElementById('steno1Panel');
        const steno2Panel = document.getElementById('steno2Panel');
        const status1 = document.getElementById('status1');
        const status2 = document.getElementById('status2');
        const match1 = document.getElementById('match1');
        const match2 = document.getElementById('match2');

        const displayModeSelect = document.getElementById('displayMode');
        const memoContent = document.getElementById('memoContent');

        // 어절 단위로 텍스트 분리 (공백 기준)
        function splitIntoWords(text) {
            return text.trim().split(/\s+/).filter(word => word.length > 0);
        }

        // 연속된 N어절 + 스페이스를 찾는 함수 (스페이스 입력 후에만 매칭)
        function findWordMatch(activeText, standbyText) {
            if (!activeText || !standbyText) return null;
            
            // 대기속기사 텍스트가 스페이스로 끝나지 않으면 매칭하지 않음
            if (!standbyText.endsWith(' ')) {
                return null;
            }
            
            const activeWords = splitIntoWords(activeText);
            const standbyWords = splitIntoWords(standbyText);
            
            // 대기 상태 속기사의 텍스트에서 연속된 N어절 조합을 찾음
            for (let i = 0; i <= standbyWords.length - matchWordsCount; i++) {
                const targetWords = standbyWords.slice(i, i + matchWordsCount);
                
                // 송출권한 속기사의 텍스트에서 이 N어절 조합이 연속적으로 있는지 확인
                for (let j = 0; j <= activeWords.length - matchWordsCount; j++) {
                    const activeSequence = activeWords.slice(j, j + matchWordsCount);
                    
                    // 어절 단위로 정확히 일치하는지 확인
                    let isMatch = true;
                    for (let k = 0; k < matchWordsCount; k++) {
                        if (targetWords[k] !== activeSequence[k]) {
                            isMatch = false;
                            break;
                        }
                    }
                    
                    if (isMatch) {
                        // 매칭된 부분까지의 텍스트 구성
                        const beforeMatchWords = activeWords.slice(0, j);
                        const matchedWords = activeWords.slice(j, j + matchWordsCount);
                        
                        return {
                            matchedWords: matchedWords.join(' '),
                            beforeMatch: beforeMatchWords.length > 0 ? beforeMatchWords.join(' ') + ' ' : '',
                            matchedPart: matchedWords.join(' '),
                            standbyFromIndex: i,
                            wordsCount: matchWordsCount,
                            direction: 'standby_to_active'
                        };
                    }
                }
            }
            
            // 반대 방향 매칭도 확인 (송출권한 속기사가 대기속기사와 매칭)
            // 송출권한 속기사 텍스트가 스페이스로 끝나지 않으면 매칭하지 않음
            if (!activeText.endsWith(' ')) {
                return null;
            }
            
            for (let i = 0; i <= activeWords.length - matchWordsCount; i++) {
                const targetWords = activeWords.slice(i, i + matchWordsCount);
                
                // 대기 상태 속기사의 텍스트에서 이 N어절 조합이 연속적으로 있는지 확인
                for (let j = 0; j <= standbyWords.length - matchWordsCount; j++) {
                    const standbySequence = standbyWords.slice(j, j + matchWordsCount);
                    
                    // 어절 단위로 정확히 일치하는지 확인
                    let isMatch = true;
                    for (let k = 0; k < matchWordsCount; k++) {
                        if (targetWords[k] !== standbySequence[k]) {
                            isMatch = false;
                            break;
                        }
                    }
                    
                    if (isMatch) {
                        // 매칭된 부분까지의 텍스트 구성
                        const beforeMatchWords = activeWords.slice(0, i);
                        const matchedWords = activeWords.slice(i, i + matchWordsCount);
                        
                        return {
                            matchedWords: matchedWords.join(' '),
                            beforeMatch: beforeMatchWords.length > 0 ? beforeMatchWords.join(' ') + ' ' : '',
                            matchedPart: matchedWords.join(' '),
                            standbyFromIndex: j,
                            wordsCount: matchWordsCount,
                            direction: 'active_to_standby'
                        };
                    }
                }
            }
            
            return null;
        }

        // 부분 매칭을 찾는 함수 (실시간 하이라이트용) - 스페이스 기준으로만 매칭
        function findPartialMatch(activeText, standbyText) {
            if (!activeText || !standbyText) return null;
            
            const activeWords = splitIntoWords(activeText);
            const standbyWords = splitIntoWords(standbyText);
            
            if (activeWords.length === 0 || standbyWords.length === 0) return null;
            
            // 최대 매칭 길이 (설정된 어절 수보다 작은 경우만)
            const maxMatchLength = Math.min(activeWords.length, standbyWords.length, matchWordsCount - 1);
            
            if (maxMatchLength < 1) return null;
            
            // 연속된 어절들이 일치하는지 확인 (스페이스로 끝나는 완성된 단어만)
            for (let length = maxMatchLength; length >= 1; length--) {
                for (let i = 0; i <= activeWords.length - length; i++) {
                    const activeSequence = activeWords.slice(i, i + length);
                    
                    for (let j = 0; j <= standbyWords.length - length; j++) {
                        const standbySequence = standbyWords.slice(j, j + length);
                        
                        // 어절 단위로 정확히 일치하는지 확인
                        let isMatch = true;
                        for (let k = 0; k < length; k++) {
                            if (activeSequence[k] !== standbySequence[k]) {
                                isMatch = false;
                                break;
                            }
                        }
                        
                        if (isMatch) {
                            // 스페이스로 끝나는 완성된 단어들만 매칭으로 인정
                            const activeTextEndsWithSpace = activeText.trim().endsWith(' ');
                            const standbyTextEndsWithSpace = standbyText.trim().endsWith(' ');
                            
                            // 둘 다 스페이스로 끝나거나, 둘 다 스페이스로 끝나지 않으면 매칭
                            if (activeTextEndsWithSpace === standbyTextEndsWithSpace) {
                                return {
                                    activeStart: i,
                                    activeEnd: i + length,
                                    standbyStart: j,
                                    standbyEnd: j + length,
                                    matchedWords: activeSequence.join(' '),
                                    matchLength: length
                                };
                            }
                        }
                    }
                }
            }
            
            return null;
        }

        // 권한 전환 함수 (수정된 버전 - 모니터링 내용 유지)
        function switchActive(matchResult = null) {
            const previousActive = activeStenographer;
            const previousInput = activeStenographer === 1 ? input1 : input2;
            const newInput = activeStenographer === 1 ? input2 : input1;
            
            // 권한 전환
            activeStenographer = activeStenographer === 1 ? 2 : 1;
            
            if (matchResult) {
                // 자동 전환의 경우: 현재 송출권한자의 완성된 텍스트를 누적
                // 매칭된 부분을 제외한 나머지 텍스트를 누적
                const currentActiveText = previousInput.value;
                const matchedWordsArray = splitIntoWords(matchResult.matchedWords);
                
                // 현재 송출권한자의 텍스트에서 매칭된 부분을 찾아서 제거
                const currentWords = splitIntoWords(currentActiveText);
                let matchIndex = -1;
                
                for (let i = 0; i <= currentWords.length - matchedWordsArray.length; i++) {
                    let isMatch = true;
                    for (let j = 0; j < matchedWordsArray.length; j++) {
                        if (currentWords[i + j] !== matchedWordsArray[j]) {
                            isMatch = false;
                            break;
                        }
                    }
                    if (isMatch) {
                        matchIndex = i;
                        break;
                    }
                }
                
                if (matchIndex >= 0) {
                    // 매칭된 부분 이전의 텍스트만 누적
                    const beforeMatchWords = currentWords.slice(0, matchIndex);
                    const beforeMatchText = beforeMatchWords.join(' ');
                    if (beforeMatchText) {
                        accumulatedText += beforeMatchText + ' ';
                    }
                } else {
                    // 매칭된 부분을 찾지 못한 경우 전체 텍스트 누적
                    accumulatedText += currentActiveText;
                }
                
                // 새로운 입력자(대기속기사)의 입력창은 그대로 유지
                

            } else {
                // 수동 전환의 경우: 현재 송출권한자의 내용을 누적
                accumulatedText += previousInput.value;
                // 새로운 입력자의 입력창은 현재 내용 유지 (비우지 않음)
            }
            
            // 이전 송출권한자의 입력창만 비우기
            previousInput.value = "";
            
            updateUI();
            updateViewer();
        }

        // UI 업데이트
        function updateUI() {
            if (activeStenographer === 1) {
                steno1Panel.classList.add('active');
                steno2Panel.classList.remove('active');
                status1.textContent = '🟢 송출권한';
                status1.className = 'status-indicator status-active';
                status2.textContent = '⏸️ 대기';
                status2.className = 'status-indicator status-standby';
                statusBar.textContent = '   속기사 1번이 현재 송출권한 상태입니다';
            } else {
                steno1Panel.classList.remove('active');
                steno2Panel.classList.add('active');
                status1.textContent = '⏸️ 대기';
                status1.className = 'status-indicator status-standby';
                status2.textContent = '🟢 송출권한';
                status2.className = 'status-indicator status-active';
                statusBar.textContent = '   속기사 2번이 현재 송출권한 상태입니다';
            }
        }

        // 모니터링 화면 업데이트 (개선된 버전 - 스페이스 입력 시 즉시 표시)
        function updateViewer() {
            const activeInput = activeStenographer === 1 ? input1 : input2;
            const currentText = accumulatedText + activeInput.value;
            
            if (!currentText) {
                viewerContent.textContent = '';
                return;
            }

            // 스페이스로 끝나는 경우 즉시 표시
            let displayText = currentText;
            
            // 스페이스로 끝나지 않는 경우만 지연 처리
            if (!currentText.endsWith(' ')) {
                const words = splitIntoWords(currentText);
                
                // 마지막 단어가 완성되지 않은 경우 지연 처리
                if (words.length > 0) {
                    // 설정된 지연 단어 수만큼 뒤에서 제외
                    const displayWords = words.slice(0, Math.max(0, words.length - displayDelayWords));
                    displayText = displayWords.join(' ');
                    
                    // 마지막에 스페이스 추가 (원래 텍스트에 스페이스가 있었다면)
                    if (displayText && currentText.indexOf(displayText) + displayText.length < currentText.length) {
                        // 원래 텍스트에서 표시할 부분 이후에 스페이스가 있는지 확인
                        const nextChar = currentText.charAt(displayText.length);
                        if (nextChar === ' ') {
                            displayText += ' ';
                        }
                    }
                }
            }
            
            viewerContent.textContent = displayText || '';
            
            // 스크롤을 맨 아래로
            viewerContent.scrollTop = viewerContent.scrollHeight;
            broadcastText(); // 이 줄 추가
        }

        // 자동 전환 확인
        function checkAutoSwitch() {
            const activeInput = activeStenographer === 1 ? input1 : input2;
            const standbyInput = activeStenographer === 1 ? input2 : input1;
            
            const activeText = accumulatedText + activeInput.value;
            const standbyText = standbyInput.value;
            
            const matchResult = findWordMatch(activeText, standbyText);
            
            if (matchResult) {
                // 자동 권한 전환
                switchActive(matchResult);
            }
        }

        // 실시간 매칭 하이라이트 업데이트
        function updateMatchingHighlight() {
            const activeInput = activeStenographer === 1 ? input1 : input2;
            const standbyInput = activeStenographer === 1 ? input2 : input1;
            
            const activeText = accumulatedText + activeInput.value;
            const standbyText = standbyInput.value;
            
            // 활성 속기사 입력창 하이라이트 제거
            clearHighlight(activeInput);
            
            // 대기 속기사 입력창 하이라이트 제거
            clearHighlight(standbyInput);
            
            // 부분 매칭 확인 및 하이라이트 적용
            const partialMatch = findPartialMatch(activeText, standbyText);
            
            if (partialMatch) {
                // 대기 속기사 입력창에 하이라이트 적용
                applyHighlight(standbyInput, partialMatch.standbyStart, partialMatch.standbyEnd, 'partial');
                
                // 활성 속기사 입력창에도 하이라이트 적용 (현재 입력 중인 부분만)
                const activeWordsInInput = splitIntoWords(activeInput.value);
                if (activeWordsInInput.length > 0) {
                    const activeStartInInput = Math.max(0, partialMatch.activeStart - splitIntoWords(accumulatedText).length);
                    const activeEndInInput = Math.min(activeWordsInInput.length, partialMatch.activeEnd - splitIntoWords(accumulatedText).length);
                    
                    if (activeStartInInput < activeEndInInput && activeStartInInput < activeWordsInInput.length) {
                        applyHighlight(activeInput, activeStartInInput, activeEndInInput, 'partial');
                    }
                }
            }
        }

        // 입력창 크기 변경 시 하이라이트 재조정
        function resizeHighlight() {
            updateMatchingHighlight();
        }

        // 하이라이트 제거
        function clearHighlight(inputElement) {
            // 기존 하이라이트 요소들 제거
            const existingHighlights = inputElement.parentNode.querySelectorAll('.input-highlight-overlay');
            existingHighlights.forEach(el => el.remove());
        }

        // 하이라이트 적용
        function applyHighlight(inputElement, startIndex, endIndex, type) {
            const text = inputElement.value;
            const words = splitIntoWords(text);
            
            if (startIndex >= words.length || endIndex > words.length) return;
            
            // 기존 하이라이트 제거
            clearHighlight(inputElement);
            
            // 오버레이 생성
            const overlay = document.createElement('div');
            overlay.className = 'input-highlight-overlay';
            const inputRect = inputElement.getBoundingClientRect();
            const parentRect = inputElement.parentNode.getBoundingClientRect();
            
            overlay.style.cssText = `
                position: absolute;
                top: ${inputElement.offsetTop}px;
                left: ${inputElement.offsetLeft}px;
                width: ${inputElement.offsetWidth}px;
                height: ${inputElement.offsetHeight}px;
                pointer-events: none;
                z-index: 1;
                background: transparent;
                font-family: inherit;
                font-size: inherit;
                line-height: inherit;
                padding: ${getComputedStyle(inputElement).padding};
                border: none;
                resize: none;
                white-space: pre-wrap;
                word-break: keep-all;
                color: transparent;
                overflow: hidden;
                box-sizing: border-box;
            `;
            
            // 단어 단위로 하이라이트 적용
            let highlightedText = '';
            let currentWordIndex = 0;
            let currentWord = '';
            let inWord = false;
            
            for (let i = 0; i < text.length; i++) {
                if (text[i] === ' ') {
                    // 단어가 완성되었을 때
                    if (inWord) {
                                            if (currentWordIndex >= startIndex && currentWordIndex < endIndex) {
                        // 매칭된 단어는 하이라이트 적용
                        highlightedText += `<span style="background: rgba(102, 126, 234, 0.15); border-radius: 2px; padding: 0; margin: 0; color: transparent; display: inline; line-height: inherit;">${currentWord}</span>`;
                    } else {
                        // 매칭되지 않은 단어는 투명하게
                        highlightedText += `<span style="color: transparent;">${currentWord}</span>`;
                    }
                        currentWord = '';
                        inWord = false;
                        currentWordIndex++;
                    }
                    highlightedText += ' ';
                } else {
                    // 단어 내부
                    if (!inWord) {
                        inWord = true;
                    }
                    currentWord += text[i];
                }
            }
            
            // 마지막 단어 처리
            if (inWord && currentWord.length > 0) {
                if (currentWordIndex >= startIndex && currentWordIndex < endIndex) {
                    highlightedText += `<span style="background: rgba(102, 126, 234, 0.15); border-radius: 2px; padding: 0; margin: 0; color: transparent; display: inline; line-height: inherit;">${currentWord}</span>`;
                } else {
                    highlightedText += `<span style="color: transparent;">${currentWord}</span>`;
                }
            }
            
            overlay.innerHTML = highlightedText;
            inputElement.parentNode.appendChild(overlay);
        }

        // 수동 권한 전환
        function manualSwitch() {
            switchActive();
        }

        // 폰트 크기 변경
        function changeFontSize(delta) {
            currentFontSize += delta * 0.1;
            if (currentFontSize < 0.8) currentFontSize = 0.8;
            if (currentFontSize > 2.0) currentFontSize = 2.0;
            viewerContent.style.fontSize = currentFontSize + 'em';
        }

        // 속기사 입력창 폰트 크기 변경
        function changeStenoFontSize(stenoNumber, delta) {
            const input = stenoNumber === 1 ? input1 : input2;
            const currentSize = parseFloat(input.style.fontSize) || 1.0;
            const newSize = currentSize + delta * 0.1;
            
            if (newSize >= 0.8 && newSize <= 2.0) {
                input.style.fontSize = newSize + 'em';
            }
        }

        // 메모장 폰트 크기 변경
        function changeMemoFontSize(delta) {
            const currentSize = parseFloat(memoContent.style.fontSize) || 1.0;
            const newSize = currentSize + delta * 0.1;
            
            if (newSize >= 0.8 && newSize <= 2.0) {
                memoContent.style.fontSize = newSize + 'em';
            }
        }

        // 뷰어 내용 지우기
        function clearViewer() {
            if (confirm('모니터링 화면을 지우시겠습니까?')) {
                accumulatedText = "";
                updateViewer();
            }
        }

        // 메모장 내용 지우기
        function clearMemo() {
            if (confirm('메모장을 지우시겠습니까?')) {
                memoContent.value = "";
            }
        }

        // 데모 리셋
        function resetDemo() {
            if (confirm('데모를 리셋하시겠습니까?')) {
                input1.value = '';
                input2.value = '';
                accumulatedText = '';
                activeStenographer = 1;
                currentFontSize = 1.1;
                matchWordsCount = 3;
                displayDelayWords = 1;
                viewerContent.style.fontSize = currentFontSize + 'em';
                memoContent.style.fontSize = '1.15rem';
                match1.style.display = 'none';
                match2.style.display = 'none';
                document.getElementById('matchWordsCount').value = '3';
                displayModeSelect.value = '1';
                viewerContent.textContent = '';
                memoContent.value = '';
                updateUI();
                updateViewer();
            }
        }

        // 자동 전환 기준 어절 수 변경 함수들
        function increaseMatchWords() {
            const input = document.getElementById('matchWordsCount');
            const currentValue = parseInt(input.value);
            if (currentValue < 7) {
                input.value = currentValue + 1;
                matchWordsCount = currentValue + 1;
                updateMatchingHighlight();
            }
        }

        function decreaseMatchWords() {
            const input = document.getElementById('matchWordsCount');
            const currentValue = parseInt(input.value);
            if (currentValue > 3) {
                input.value = currentValue - 1;
                matchWordsCount = currentValue - 1;
                updateMatchingHighlight();
            }
        }

        // 표시 지연 설정 변경
        displayModeSelect.addEventListener('change', (e) => {
            displayDelayWords = parseInt(e.target.value);
            updateViewer();
        });

        // 이벤트 리스너
        input1.addEventListener('input', () => {
            if (activeStenographer === 1) {
                updateViewer();
            }
            checkAutoSwitch();
            setTimeout(updateMatchingHighlight, 10);
        });

        input2.addEventListener('input', () => {
            if (activeStenographer === 2) {
                updateViewer();
            }
            checkAutoSwitch();
            setTimeout(updateMatchingHighlight, 10);
        });

        // 입력창 크기 변경 감지
        const resizeObserver = new ResizeObserver(() => {
            setTimeout(resizeHighlight, 10);
        });

        resizeObserver.observe(input1);
        resizeObserver.observe(input2);

        // 키보드 단축키
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.code === 'Space') {
                e.preventDefault();
                manualSwitch();
            } else if (e.ctrlKey && e.code === 'KeyD') {
                e.preventDefault();
                clearViewer();
            }
        });

        // 송출 함수
        const bc = new BroadcastChannel('steno');
        function broadcastText() {
          const activeInput = activeStenographer === 1 ? input1 : input2;
          const currentText = accumulatedText + activeInput.value;
          bc.postMessage(currentText);
        }

        // 뷰어 창 열기 함수
        let viewerWindow = null;
        function openViewer() {
          if (viewerWindow && !viewerWindow.closed) {
            viewerWindow.focus();
          } else {
            viewerWindow = window.open('viewer.html', 'viewer', 'width=1200,height=800,resizable=yes');
          }
        }

        // 초기 설정
        updateUI();
        updateViewer();

        function selectUtilityTab(tabNum) {
            document.getElementById('utilityTab1').classList.remove('active');
            document.getElementById('utilityTab2').classList.remove('active');
            document.getElementById('utilityContent1').style.display = 'none';
            document.getElementById('utilityContent2').style.display = 'none';
            if(tabNum === 1) {
                document.getElementById('utilityTab1').classList.add('active');
                document.getElementById('utilityContent1').style.display = '';
            } else {
                document.getElementById('utilityTab2').classList.add('active');
                document.getElementById('utilityContent2').style.display = '';
            }
        }
    </script>
</body>
</html>
